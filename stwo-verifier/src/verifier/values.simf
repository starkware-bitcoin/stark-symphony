// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef VERIFIER_QUERIES_SIMF
#define VERIFIER_QUERIES_SIMF

#include "channel/state.simf"
#include "fields/qm31.simf"
#include "groups/qm31_point.simf"
#include "poly/evaluations.simf"
#include "verifier/proof.simf"
#include "vcs/hasher.simf"
#include "vcs/merkle.simf"
#include "utils/list_map.simf"
#include "utils/list_zip.simf"
#include "fri/answers.simf"

/// Pair of a query and a decommitment.
type QueryDecommitment = (u32, Decommitment);

/// Reads the trace/cp polynomial commitments and samples random CP coefficient.
/// Returns the updated channel state and random CP coefficient.
fn commit(state: ChannelState, commitments: Commitments) -> (ChannelState, QM31) {
    let (const_root, trace_root, cp_root): Commitments = commitments;

    // Read preprocessed tree root (aka constant trace)
    let state: ChannelState = channel_mix_u256(state, const_root);
    // Read trace root
    let state: ChannelState = channel_mix_u256(state, trace_root);

    // Draw random coefficient for CP evaluation
    let (state, random_coeff): (ChannelState, QM31) = channel_draw_qm31(state);

    // Read composition polynomial commitment root
    let state: ChannelState = channel_mix_u256(state, cp_root);

    (state, random_coeff)
}

/// Decommit trace polynomial evaluations at queried position.
fn decommit_trace_evals(query: u32, decommitment: TraceDecommitment, root: MerkleNode) -> TraceEvalsM31 {
    let (evals, proof): (TraceEvalsM31, MerkleProof32) = decommitment;
    let trace_node: MerkleNode = hash_node_m31_trace(evals);
    // Auth path is query + num_leaves
    let (_, auth_path): (bool, u32) = jet::add_32(query, 16);
    merkle_verify_32(trace_node, auth_path, proof, root);
    evals
}

/// Decommit composition polynomial evaluation at queried position.
fn decommit_cp_evals(query: u32, decommitment: CpDecommitment, root: MerkleNode) -> CPEvalM31 {
    let (evals, proof): (CPEvalM31, MerkleProof32) = decommitment;
    let cp_node: MerkleNode = dbg!(hash_node_m31_cp(evals));
    // Auth path is query + num_leaves
    let (_, auth_path): (bool, u32) = jet::add_32(query, 16);
    merkle_verify_32(cp_node, auth_path, proof, root);
    evals
}

/// Decommit a single query and output a tuple of the query response and the unchanged context (roots).
/// This is a mapper function.
fn decommit_query(query_decommitment: QueryDecommitment, roots: Commitments) -> (QueryResponse, Commitments) {
    let (query, (trace_decommitment, cp_decommitment)): QueryDecommitment = query_decommitment;
    let (_, trace_root, cp_root): Commitments = roots;
    let trace_evals: TraceEvalsM31 = decommit_trace_evals(query, trace_decommitment, trace_root);
    let cp_evals: CPEvalM31 = decommit_cp_evals(query, cp_decommitment, cp_root);
    ((query, trace_evals, cp_evals), roots)
}

/// Zip queries with decommitments.
DEFINE_ZIP_ARR_2(query_decommitments, u32, Decommitment)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 4, 2)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 8, 4)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 16, 8)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 32, 16)
DEFINE_ZIP_LST_2(query_decommitments, u32, Decommitment)
DEFINE_ZIP_LST(query_decommitments, u32, Decommitment, 4, 2)
DEFINE_ZIP_LST(query_decommitments, u32, Decommitment, 8, 4)
DEFINE_ZIP_LST(query_decommitments, u32, Decommitment, 16, 8)
DEFINE_ZIP_LST(query_decommitments, u32, Decommitment, 32, 16)

/// Map decommitments to query responses.
DEFINE_MAP_ARR_2(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 4, 2)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 8, 4)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 16, 8)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 32, 16)
DEFINE_MAP_LST_2(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query)
DEFINE_MAP_LST(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 4, 2)
DEFINE_MAP_LST(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 8, 4)
DEFINE_MAP_LST(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 16, 8)
DEFINE_MAP_LST(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 32, 16)

/// Verify decommitments of queried trace & cp evaluations.
/// Returns the updated channel state and the list of query responses.
fn decommit(queries: List<u32, MAX_FRI_QUERIES>, decommitments: Decommitments, roots: Commitments) -> QueryResponses {
    // Zip queries with decommitments
    let zipped_items: List<QueryDecommitment, MAX_FRI_QUERIES> = query_decommitments_zip_lst_32(queries, decommitments);
    // Decommit queries and output a list of tuples (query, trace_evals, cp_evals)
    let (responses, _): (QueryResponses, Commitments) = query_responses_map_lst_32(zipped_items, roots);
    responses
}

fn test_commit() {
    let state: ChannelState = (0, 0);
    let commitments: Commitments = (
        0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,
        0x2151e980c7ae914e9b486e36b8392db505e1848bd7dcc89329245c61cdb95096,
        0xe85deb2eaadb5e5376ce81ffb6ee36eab838c2a97686f83d5de609ba03845e0c,
    );
    let ((digest, _), random_coeff): (ChannelState, QM31) = commit(state, commitments);
    assert!(jet::eq_256(digest, 0x94642214378090859916af45c596713b6d8abaa2c72f3ed8ad41f869ad35491b));
    assert!(qm31_eq(random_coeff, qm31(2012724549, 1128459570, 1584582850, 1454574268)));
}

fn test_decommit_query() {
    let roots: Commitments = (
        0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,
        0x2143f75d71572fd6cc57f586b6713dd237ce03e0e6992ef8e2199ed653129c7f,
        0x83e5557f761f237e20462300295aa53c3480f3f0907bd5b1e4f89ffdc6f950bc,
    );
    let decommitment: Decommitment = (
        (
            list![list![1], list![495602521], list![1874631582], list![1174813791]], // trace evaluations
            list![0x61d89893714f17dacc2219d98fe3213716140fb03a2b712ddfe03fdac7b74b2d, 0x97e6ead6d49cc7289a7ec47c2c09ae05851c06dde5028b976c3a8a03c547bfa1, 0xd02fe24628e6d523938e57fc793a98c320e4b75b121faa830d2e8f95f2abaee0], // trace decommitment
        ),
        (
            [1840623278, 1926730915, 2147287039, 0, 1265893248, 993651831, 0, 0, 236821717, 325156552, 0, 0, 2110497226, 1488481922, 0, 0], // cp evaluations
            list![0x2b1f2f773bdf244640f9aaa3a3ba28aa7a413cbc28c1acf7f1a8c27e14e14cf3, 0x81886da63943805c745dbabf91e86d53f89ce5c850f52ec5e8ead438ce4418c9, 0xf628a1fa959d01d179e48d47c159e90990585cea53ca23fb8bcbdfc30781201b], // cp decommitment
        ),
    );
    let query: u32 = 5;
    let _: (QueryResponse, Commitments) = decommit_query((query, decommitment), roots);
}

#endif
