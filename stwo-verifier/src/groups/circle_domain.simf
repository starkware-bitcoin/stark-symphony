// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef CIRCLE_DOMAIN_H
#define CIRCLE_DOMAIN_H

#include "groups/coset.simf"

/// Circle domain is a canonic (standard) coset, defined by parameters of its half coset:
///  * half_size: 2^(n-1) where n is the log_size of the canonic coset
///  * offset: 2^(31-(n+1))
///  * step: 2^(31-(n-1))
type CircleDomain = (u32, u32, u32);

/// Creates a canonic (standard) coset of size 2^log_size.
fn circle_domain(log_size: u8) -> CircleDomain {
    let (_, log_size_minus_1): (bool, u8) = jet::subtract_8(log_size, 1);
    let (_, log_size_plus_1): (bool, u8) = jet::add_8(log_size, 1);
    let half_size: u32 = jet::left_shift_32(log_size_minus_1, 1);
    let offset: u32 = circle_subgroup_gen(log_size_plus_1);
    let step: u32 = circle_subgroup_gen(log_size_minus_1);
    (half_size, offset, step)
}

/// Converts a position (number of an element) to a point index.
fn circle_position_to_point_index(domain: CircleDomain, position: u32) -> u32 {
    let (half_size, offset, step): (u32, u32, u32) = domain;
    match jet::lt_32(position, half_size) {
        true => circle_point_index_add(offset, circle_point_index_mul(step, position)),
        false => {
            let (_, position): (bool, u32) = jet::subtract_32(position, half_size);
            let index: u32 = circle_point_index_add(offset, circle_point_index_mul(step, position));
            circle_point_index_neg(index)
        }
    }
}

/// Converts a position (number of an element) to a point on the circle domain.
fn circle_position_to_m31_point(domain: CircleDomain, position: u32) -> M31Point {
    let index: u32 = circle_position_to_point_index(domain, position);
    circle_point_index_to_m31_point(index)
}

#ifdef TESTING

fn test_circle_domain() {
    let (half_size, offset, step): (u32, u32, u32) = circle_domain(11);
    assert!(jet::eq_32(half_size, 1024));
    assert!(jet::eq_32(offset, 524288));
    assert!(jet::eq_32(step, 2097152));
}

fn test_circle_position_to_point_index() {
    let domain: CircleDomain = circle_domain(11);
    let position: u32 = 1133;
    let point_index: u32 = circle_position_to_point_index(domain, position);
    assert!(jet::eq_32(point_index, 1918369792));
}

fn test_circle_position_to_point_index_2() {
    let domain: CircleDomain = circle_domain(11);
    let position: u32 = 201;
    let point_index: u32 = circle_position_to_point_index(domain, position);
    assert!(jet::eq_32(point_index, 422051840));
}

#endif // TESTING

#endif
