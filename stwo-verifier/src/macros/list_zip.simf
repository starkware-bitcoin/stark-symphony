// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

//! Helpers for zipping two lists.

#ifndef UTILS_LIST_ZIP_SIMF
#define UTILS_LIST_ZIP_SIMF

/// Zip two arrays of size 2.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the first array.
/// * `T2` is the type of the elements in the second array.
#define DEFINE_ZIP_ARR_2(PREFIX, T1, T2) \
fn PREFIX##_zip_arr_2(arr1: [T1; 2], arr2: [T2; 2]) -> [(T1, T2); 2] { \
    let (elt1_1, elt1_2): (T1, T1) = <[T1; 2]>::into(arr1); \
    let (elt2_1, elt2_2): (T2, T2) = <[T2; 2]>::into(arr2); \
    [(elt1_1, elt2_1), (elt1_2, elt2_2)] \
}

/// Zip two arrays of size N.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the first array.
/// * `T2` is the type of the elements in the second array.
/// * `N` is the size of the arrays.
/// * `HALF_N` is the size of the arrays after splitting in half.
#define DEFINE_ZIP_ARR(PREFIX, T1, T2, N, HALF_N) \
fn PREFIX##_zip_arr_##N(arr1: [T1; N], arr2: [T2; N]) -> [(T1, T2); N] { \
    let (arr1_1, arr1_2): ([T1; HALF_N], [T1; HALF_N]) = <[T1; N]>::into(arr1); \
    let (arr2_1, arr2_2): ([T2; HALF_N], [T2; HALF_N]) = <[T2; N]>::into(arr2); \
    let res_1: [(T1, T2); HALF_N] = PREFIX##_zip_arr_##HALF_N(arr1_1, arr2_1); \
    let res_2: [(T1, T2); HALF_N] = PREFIX##_zip_arr_##HALF_N(arr1_2, arr2_2); \
    <([(T1, T2); HALF_N], [(T1, T2); HALF_N])>::into((res_1, res_2)) \
}

/// Zip two lists of size <2.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the first list.
/// * `T2` is the type of the elements in the second list.
#define DEFINE_ZIP_LST_2(PREFIX, T1, T2) \
fn PREFIX##_zip_lst_2(l1: List<T1, 2>, l2: List<T2, 2>) -> List<(T1, T2), 2> { \
    let elt1: Option<T1> = <List<T1, 2>>::into(l1); \
    let elt2: Option<T2> = <List<T2, 2>>::into(l2); \
    match elt1 { \
        Some(elt1: T1) => { \
            match elt2 { \
                Some(elt2: T2) => list![(elt1, elt2)], \
                None => panic!(), \
            } \
        }, \
        None => { \
            match elt2 { \
                Some(elt2: T2) => panic!(), \
                None => list![], \
            } \
        } \
    } \
}

/// Zip two lists of size <N.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the first list.
/// * `T2` is the type of the elements in the second list.
/// * `N` is the max size of the lists.
/// * `HALF_N` is the max size of the lists after splitting in half.
#define DEFINE_ZIP_LST(PREFIX, T1, T2, N, HALF_N) \
fn PREFIX##_zip_lst_##N(l1: List<T1, N>, l2: List<T2, N>) -> List<(T1, T2), N> { \
    let (l1_arr, l1_lst): (Option<[T1; HALF_N]>, List<T1, HALF_N>) = <List<T1, N>>::into(l1); \
    let (l2_arr, l2_lst): (Option<[T2; HALF_N]>, List<T2, HALF_N>) = <List<T2, N>>::into(l2); \
    let res_arr: Option<[(T1, T2); HALF_N]> = match l1_arr { \
        Some(arr1: [T1; HALF_N]) => { \
            match l2_arr { \
                Some(arr2: [T2; HALF_N]) => Some(PREFIX##_zip_arr_##HALF_N(arr1, arr2)), \
                None => panic!(), \
            } \
        }, \
        None => { \
            match l2_arr { \
                Some(arr2: [T2; HALF_N]) => panic!(), \
                None => None, \
            } \
        }, \
    }; \
    let res_lst: List<(T1, T2), HALF_N> = PREFIX##_zip_lst_##HALF_N(l1_lst, l2_lst); \
    <(Option<[(T1, T2); HALF_N]>, List<(T1, T2), HALF_N>)>::into((res_arr, res_lst)) \
}

// The order in which we define function matters.
// First we define zippers for arrays, then lists.
// First for lower sizes, then for higher sizes.
DEFINE_ZIP_ARR_2(num, u32, u32)
DEFINE_ZIP_ARR(num, u32, u32, 4, 2)
DEFINE_ZIP_ARR(num, u32, u32, 8, 4)

DEFINE_ZIP_LST_2(num, u32, u32)
DEFINE_ZIP_LST(num, u32, u32, 4, 2)
DEFINE_ZIP_LST(num, u32, u32, 8, 4)

fn test_zip_lst_8() {
    let a: List<u32, 8> = list![1, 2, 3, 4, 5];
    let zipped: List<(u32, u32), 8> = num_zip_lst_8(a, a);
}

#endif
