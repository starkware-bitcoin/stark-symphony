// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef POLY_EVALUATIONS_H
#define POLY_EVALUATIONS_H

#include "fields/qm31.simf"
#include "groups/qm31_point.simf"
#include "utils/list_get.simf"

/// Maximum supported offset for an AIR column with transition constraints.
/// Upper bound not included, i.e. offset is in range [0, COL_MAX_OFFSET).
#define COL_MAX_OFFSET 4

/// Maximum supported number of columns in the AIR.
/// Upper bound not included, i.e. offset is in range [0, MAX_COLUMNS).
#define MAX_COLUMNS 256

/// A list of evaluations in QM31 for a given column.
/// TODO: consider using a tuple instead, we need at most 2 for Plonk.
type ColEvalsQM31 = List<QM31, COL_MAX_OFFSET>;

/// A list of evaluations in M31 for a given column.
type ColEvalsM31 = List<M31, COL_MAX_OFFSET>;

/// A list of evaluations in QM31 for all columns.
/// Assumming single component.
type TraceEvalsQM31 = List<ColEvalsQM31, MAX_COLUMNS>;

/// A list of evaluations in M31 for all columns.
/// Assumming single component.
type TraceEvalsM31 = List<ColEvalsM31, MAX_COLUMNS>;

/// Partitioned composition polynomial evaluation.
/// 4 coordinates x 4 decomposed polynomials (reducing degree by one).
type CPEvalQM31 = [QM31; 16];

/// Partitioned composition polynomial evaluation in M31.
/// 4 coordinates x 4 decomposed polynomials (reducing degree by one)
type CPEvalM31 = [M31; 16];

/// Trace evaluations and composition polynomial evaluation at OODS point
type OodsEvals = (TraceEvalsQM31, CPEvalQM31);

/// Reconstructs a composition polynomial evaluation from the partitioned evaluations.
fn composition_poly_eval_from_partitions(partitioned_cp_eval: (QM31, QM31, QM31, QM31)) -> QM31 {
    let (cp0, cp1, cp2, cp3): (QM31, QM31, QM31, QM31) = partitioned_cp_eval;
    let res: QM31 = qm31_add(cp0, qm31_mul(cp1, qm31(0, 1, 0, 0)));
    let res: QM31 = qm31_add(res, qm31_mul(cp2, qm31(0, 0, 1, 0)));
    let res: QM31 = qm31_add(res, qm31_mul(cp3, qm31(0, 0, 0, 1)));
    res
}

/// Reconstructs composition polynomial evaluation from decomposed partitioned evaluations.
fn composition_poly_eval_from_decomposed(decomposed_cp_eval: CPEvalQM31, oods_point: QM31Point) -> QM31 {
    let (a0, b0, c0, d0, a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3): (QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31) 
        = <CPEvalQM31>::into(decomposed_cp_eval);
    let cpa: QM31 = composition_poly_eval_from_partitions((a0, a1, a2, a3));
    let cpb: QM31 = composition_poly_eval_from_partitions((b0, b1, b2, b3));
    let cpc: QM31 = composition_poly_eval_from_partitions((c0, c1, c2, c3));
    let cpd: QM31 = composition_poly_eval_from_partitions((d0, d1, d2, d3));
    // F(x, y) = F_a(X, Y) + x * F_b(X, Y) + y * F_c(X, Y) + x * y * F_d(X, Y)
    let (x, y): (QM31, QM31) = oods_point;
    let res: QM31 = qm31_add(cpa, qm31_mul(cpb, y));
    let res: QM31 = qm31_add(res, qm31_mul(cpc, x));
    qm31_add(res, qm31_mul(cpd, qm31_mul(x, y)))
}

DEFINE_GET_ARR_2(qm31, QM31)
DEFINE_GET_ARR(qm31, QM31, 4, 2)
DEFINE_GET_LST_2(qm31, QM31)
DEFINE_GET_LST(qm31, QM31, 4, 2)

DEFINE_GET_ARR_2(m31, M31)
DEFINE_GET_ARR(m31, M31, 4, 2)
DEFINE_GET_LST_2(m31, M31)
DEFINE_GET_LST(m31, M31, 4, 2)

/// Get an evaluation from a column evaluations list given an offset.
/// If the offset is out of bounds, the function will panic.
fn col_evals_qm31_get(col_evals: ColEvalsQM31, offset: u32) -> QM31 {
    qm31_unwrap(qm31_get_lst_4(col_evals, offset))
}

/// Get an evaluation from a column evaluations list given an offset.
/// If the offset is out of bounds, the function will panic.
fn col_evals_m31_get(col_evals: ColEvalsM31, offset: u32) -> M31 {
    m31_unwrap(m31_get_lst_4(col_evals, offset))
}

fn test_composition_poly_eval_from_partitions() {
    let partitioned_cp_eval: (QM31, QM31, QM31, QM31) = (
        qm31(102457172, 120697777, 684798907, 704325503),
        qm31(1524382544, 864965792, 1090724300, 832226163),
        qm31(1447800586, 1051306930, 2035698572, 902029335),
        qm31(1674296998, 584689294, 411846336, 680031775)
    );
    let expected: QM31 = qm31(634949303, 1333531166, 715684036, 225686437);

    let cp_eval: QM31 = composition_poly_eval_from_partitions(partitioned_cp_eval);
    assert!(qm31_eq(cp_eval, expected));
}

fn test_composition_poly_eval_from_decomposed() {
}

#endif
