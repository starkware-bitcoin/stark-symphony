// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef EVALS_DECOMMIT_SIMF
#define EVALS_DECOMMIT_SIMF

#include "config.simf"
#include "merkle.simf"
#include "evals/commit.simf"
#include "evals/trace_poly.simf"
#include "evals/composition_poly.simf"
#include "fri/queries.simf"
#include "macros/array_map.simf"
#include "macros/array_zip.simf"

/// Composition polynomial decommitment:
/// * partitioned evaluations in M31
/// * Merkle proof
type CpDecommitment = (CPEvalM31, MerkleProof32);

/// Trace decommitment:
/// * evaluations in M31
/// * Merkle proof
type TraceDecommitment = (TraceEvalsM31, MerkleProof32);

/// Decommitment:
/// * trace decommitment
/// * composition polynomial decommitment
type Decommitment = (TraceDecommitment, CpDecommitment);

/// Decommitments:
/// * decommitments for each FRI query
type Decommitments = [Decommitment; NUM_FRI_QUERIES];

/// Pair of a query and a decommitment.
type QueryDecommitment = (u32, Decommitment);

/// Response to a single FRI query.
type QueryResponse = (u32, TraceEvalsM31, CPEvalM31);

/// List of query responses.
type QueryResponses = [QueryResponse; NUM_FRI_QUERIES];

/// Decommit trace polynomial evaluations at queried position.
fn decommit_trace_evals(query: u32, decommitment: TraceDecommitment, root: MerkleNode) -> TraceEvalsM31 {
    let (evals, proof): (TraceEvalsM31, MerkleProof32) = decommitment;
    let trace_node: MerkleNode = hash_node_m31_trace(evals);
    // Auth path is query + num_leaves
    let (_, auth_path): (bool, u32) = jet::add_32(query, 16);
    merkle_verify_32(trace_node, auth_path, proof, root);
    evals
}

/// Decommit composition polynomial evaluation at queried position.
fn decommit_cp_evals(query: u32, decommitment: CpDecommitment, root: MerkleNode) -> CPEvalM31 {
    let (evals, proof): (CPEvalM31, MerkleProof32) = decommitment;
    let cp_node: MerkleNode = dbg!(hash_node_m31_cp(evals));
    // Auth path is query + num_leaves
    let (_, auth_path): (bool, u32) = jet::add_32(query, 16);
    merkle_verify_32(cp_node, auth_path, proof, root);
    evals
}

/// Decommit a single query and output a tuple of the query response and the unchanged context (roots).
/// This is a mapper function.
fn decommit_query(query_decommitment: QueryDecommitment, roots: Commitments) -> (QueryResponse, Commitments) {
    let (query, (trace_decommitment, cp_decommitment)): QueryDecommitment = query_decommitment;
    let (_, trace_root, cp_root): Commitments = roots;
    let trace_evals: TraceEvalsM31 = decommit_trace_evals(query, trace_decommitment, trace_root);
    let cp_evals: CPEvalM31 = decommit_cp_evals(query, cp_decommitment, cp_root);
    ((query, trace_evals, cp_evals), roots)
}

/// Zip queries with decommitments to get query decommitments (u32, Decommitment).
/// CONFIG: use the macro for the current NUM_FRI_QUERIES.
DEFINE_ZIP_ARR_1(query_decommitments, u32, Decommitment)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 2, 1)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 4, 2)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 8, 4)
DEFINE_ZIP_ARR(query_decommitments, u32, Decommitment, 16, 8)

/// Zip queries with decommitments to get query decommitments (u32, Decommitment).
fn query_decommitments_zip_arr(queries: [u32; NUM_FRI_QUERIES], decommitments: Decommitments) -> [QueryDecommitment; NUM_FRI_QUERIES] {
#ifdef TESTING
    query_decommitments_zip_arr_1(queries, decommitments)
#else
    query_decommitments_zip_arr_16(queries, decommitments)
#endif // TESTING
}

/// Map query decommitments to query responses.
/// CONFIG: use the macro for the current NUM_FRI_QUERIES.
DEFINE_MAP_ARR_1(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 2, 1)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 4, 2)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 8, 4)
DEFINE_MAP_ARR(query_responses, QueryDecommitment, QueryResponse, Commitments, decommit_query, 16, 8)

/// Map query decommitments to query responses.
fn query_responses_map_arr(query_decommitments: [QueryDecommitment; NUM_FRI_QUERIES], commitments: Commitments) -> ([QueryResponse; NUM_FRI_QUERIES], Commitments) {
#ifdef TESTING
    query_responses_map_arr_1(query_decommitments, commitments)
#else
    query_responses_map_arr_16(query_decommitments, commitments)
#endif // TESTING
}

/// Read FRI query positions and decommit evaluations at those positions.
fn evals_decommit(state: ChannelState, log_size: u8, commitments: Commitments, decommitments: Decommitments) -> (ChannelState, QueryResponses) {
    // Get FRI query positions
    let (state, queries): (ChannelState, [u32; NUM_FRI_QUERIES]) = fri_generate_queries(state, log_size);

    // Zip queries with decommitments to get query decommitments (u32, Decommitment).
    let query_decommitments: [QueryDecommitment; NUM_FRI_QUERIES] = query_decommitments_zip_arr(queries, decommitments);

    // Map query decommitments to query responses.
    let (query_responses, _): (QueryResponses, Commitments) = query_responses_map_arr(query_decommitments, commitments);

    (state, query_responses)
}

fn test_decommit_query() {
    let roots: Commitments = (
        0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,
        0x2143f75d71572fd6cc57f586b6713dd237ce03e0e6992ef8e2199ed653129c7f,
        0x83e5557f761f237e20462300295aa53c3480f3f0907bd5b1e4f89ffdc6f950bc,
    );
    let decommitment: Decommitment = (
        (
            [[1], [495602521], [1874631582], [1174813791]], // trace evaluations
            list![0x61d89893714f17dacc2219d98fe3213716140fb03a2b712ddfe03fdac7b74b2d, 0x97e6ead6d49cc7289a7ec47c2c09ae05851c06dde5028b976c3a8a03c547bfa1, 0xd02fe24628e6d523938e57fc793a98c320e4b75b121faa830d2e8f95f2abaee0], // trace decommitment
        ),
        (
            [1840623278, 1926730915, 2147287039, 0, 1265893248, 993651831, 0, 0, 236821717, 325156552, 0, 0, 2110497226, 1488481922, 0, 0], // cp evaluations
            list![0x2b1f2f773bdf244640f9aaa3a3ba28aa7a413cbc28c1acf7f1a8c27e14e14cf3, 0x81886da63943805c745dbabf91e86d53f89ce5c850f52ec5e8ead438ce4418c9, 0xf628a1fa959d01d179e48d47c159e90990585cea53ca23fb8bcbdfc30781201b], // cp decommitment
        ),
    );
    let query: u32 = 5;
    let _: (QueryResponse, Commitments) = decommit_query((query, decommitment), roots);
}

#endif
