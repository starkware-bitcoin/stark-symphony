// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef EVALS_COMPOSITION_POLY_SIMF
#define EVALS_COMPOSITION_POLY_SIMF

#include "fields/qm31.simf"
#include "groups/qm31_point.simf"

/// Partitioned composition polynomial evaluation.
/// 4 coordinates x 4 decomposed polynomials (reducing degree by one).
type CPEvalQM31 = [QM31; 16];

/// Partitioned composition polynomial evaluation in M31.
/// 4 coordinates x 4 decomposed polynomials (reducing degree by one)
type CPEvalM31 = [M31; 16];

/// Accumulator for the pi function
type PiFnAcc = QM31;

/// pi function: x -> 2*x^2 - 1
fn pi_fn(acc: PiFnAcc, n_iter: u8, counter: u8) -> Either<QM31, PiFnAcc> {
    match jet::eq_8(counter, n_iter) {
        true => Left(acc),
        false => {
            let x_dbl: QM31 = qm31_point_dbl_x(acc);
            Right(x_dbl)
        }
    }
}

/// Reconstructs a composition polynomial evaluation from the partitioned evaluations.
fn composition_poly_eval_from_partitions(partitioned_cp_eval: (QM31, QM31, QM31, QM31)) -> QM31 {
    let (cp0, cp1, cp2, cp3): (QM31, QM31, QM31, QM31) = partitioned_cp_eval;
    let res: QM31 = qm31_add(cp0, qm31_mul(cp1, qm31(0, 1, 0, 0)));
    let res: QM31 = qm31_add(res, qm31_mul(cp2, qm31(0, 0, 1, 0)));
    let res: QM31 = qm31_add(res, qm31_mul(cp3, qm31(0, 0, 0, 1)));
    res
}

/// Reconstructs composition polynomial evaluation from decomposed partitioned evaluations.
fn composition_poly_eval_from_decomposed(decomposed_cp_eval: CPEvalQM31, oods_point: QM31Point) -> QM31 {
    let (a0, b0, c0, d0, a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3): (QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31, QM31) 
        = <CPEvalQM31>::into(decomposed_cp_eval);
    let cpa: QM31 = composition_poly_eval_from_partitions((a0, a1, a2, a3));
    let cpb: QM31 = composition_poly_eval_from_partitions((b0, b1, b2, b3));
    let cpc: QM31 = composition_poly_eval_from_partitions((c0, c1, c2, c3));
    let cpd: QM31 = composition_poly_eval_from_partitions((d0, d1, d2, d3));
    // F(x, y) = F_a(X, Y) + x * F_b(X, Y) + y * F_c(X, Y) + x * y * F_d(X, Y)
    let (x, y): (QM31, QM31) = oods_point;
    let res: QM31 = qm31_add(cpa, qm31_mul(cpb, y));
    let res: QM31 = qm31_add(res, qm31_mul(cpc, x));
    qm31_add(res, qm31_mul(cpd, qm31_mul(x, y)))
}

/// Evaluate the polynomial that vanishes on the coset of size 2^log_size at a given point on circle (QM31)
///
/// Vanishing poly on a circle domain of size 2 is just x coordinate V_2(x,y) = x, because the standard canonic coset is {(0,y), (0,-y)}. 
/// Then, if we take domain of size 4 youâ€™d need to double all the points (doubling a standard coset gives a standard coset) 
/// to make them lie on the y axis, so V_4(x,y)=2x^2-1, etc up to log_size - 1.
fn vanishing_poly_eval(log_size: u8, point: QM31Point) -> QM31 {
    let (x, _): (QM31, QM31) = point;
    let (_, n_iter): (bool, u8) = jet::subtract_8(log_size, 1);
    let res: Either<QM31, PiFnAcc> = for_while::<pi_fn>(x, n_iter);
    unwrap_left::<PiFnAcc>(res)
}

fn test_composition_poly_eval_from_partitions() {
    let partitioned_cp_eval: (QM31, QM31, QM31, QM31) = (
        qm31(102457172, 120697777, 684798907, 704325503),
        qm31(1524382544, 864965792, 1090724300, 832226163),
        qm31(1447800586, 1051306930, 2035698572, 902029335),
        qm31(1674296998, 584689294, 411846336, 680031775)
    );
    let expected: QM31 = qm31(634949303, 1333531166, 715684036, 225686437);

    let cp_eval: QM31 = composition_poly_eval_from_partitions(partitioned_cp_eval);
    assert!(qm31_eq(cp_eval, expected));
}

fn test_vanishing_poly_eval() {
    let log_size: u8 = 2;
    let point: QM31Point = (
        qm31(853359656, 1678958373, 358478267, 760744889),
        qm31(23994856, 240802263, 189516568, 1941571865)
    );
    let result: QM31 = vanishing_poly_eval(log_size, point);
    let expected: QM31 = qm31(1577521274, 883254348, 2004066876, 1290622108);
    assert!(qm31_eq(result, expected));
}

#endif
