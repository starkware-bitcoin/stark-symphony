// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef EVALS_TRACE_POLY_SIMF
#define EVALS_TRACE_POLY_SIMF

#include "config.simf"
#include "fields/qm31.simf"
#include "groups/qm31_point.simf"
#include "macros/array_get.simf"

/// An array of evaluations in QM31 for a given column.
type ColEvalsQM31 = [QM31; MAX_COLUMN_OFFSET];

/// An array of evaluations in M31 for a given column.
type ColEvalsM31 = [M31; MAX_COLUMN_OFFSET];

/// An array of evaluations in QM31 for all columns.
/// Assumming single component.
type TraceEvalsQM31 = [ColEvalsQM31; NUM_COLUMNS];

/// An array of evaluations in M31 for all columns.
/// Assumming single component.
type TraceEvalsM31 = [ColEvalsM31; NUM_COLUMNS];

// CONFIG: define the macros for the current MAX_COLUMN_OFFSET.
DEFINE_GET_ARR_1(col_evals_qm31, QM31)
DEFINE_GET_ARR_1(col_evals_m31, M31)

/// Get an evaluation from a column evaluations list given an offset.
/// If the offset is out of bounds, the function will panic.
fn col_evals_qm31_get(col_evals: ColEvalsQM31, offset: u32) -> QM31 {
    // CONFIG: use the macro for the current MAX_COLUMN_OFFSET.
    qm31_unwrap(col_evals_qm31_get_arr_1(col_evals, offset))
}

/// Get an evaluation from a column evaluations list given an offset.
/// If the offset is out of bounds, the function will panic.
fn col_evals_m31_get(col_evals: ColEvalsM31, offset: u32) -> M31 {
    // CONFIG: use the macro for the current MAX_COLUMN_OFFSET.
    m31_unwrap(col_evals_m31_get_arr_1(col_evals, offset))
}

fn test_col_evals_qm31_get() {
    let col_evals: ColEvalsQM31 = [qm31(1, 2, 3, 4)];
    let res: QM31 = col_evals_qm31_get(col_evals, 0);
    assert!(qm31_eq(res, qm31(1, 2, 3, 4)));
}

fn test_col_evals_m31_get() {
    let col_evals: ColEvalsM31 = [1];
    let res: M31 = col_evals_m31_get(col_evals, 0);
    assert!(m31_eq(res, 1));
}

#endif
