//! SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//!
//! SPDX-License-Identifier: MIT

//! Helpers for mapping a list.

#ifndef UTILS_LIST_MAP_SIMF
#define UTILS_LIST_MAP_SIMF

/// Map an array of size 2.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the array.
/// * `T2` is the type of the elements in the array after mapping.
/// * `CTX` is the context of the mapping function.
/// * `F` is the mapping function.
/// Returns a tuple of the mapped array and the updated context.
#define DEFINE_MAP_ARR_2(PREFIX, T1, T2, CTX, F) \
fn PREFIX##_map_arr_2(arr: [T1; 2], ctx: CTX) -> ([T2; 2], CTX) { \
    let (elt1, elt2): (T1, T1) = <[T1; 2]>::into(arr); \
    let (res1, ctx): (T2, CTX) = F(elt1, ctx); \
    let (res2, ctx): (T2, CTX) = F(elt2, ctx); \
    ([res1, res2], ctx) \
}

/// Map an array of size N.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the array.
/// * `T2` is the type of the elements in the array after mapping.
/// * `N` is the size of the array.
/// * `HALF_N` is the size of the array after splitting in half.
/// * `CTX` is the context of the mapping function.
/// Returns a tuple of the mapped array and the updated context.
#define DEFINE_MAP_ARR(PREFIX, T1, T2, CTX, F, N, HALF_N) \
fn PREFIX##_map_arr_##N(arr: [T1; N], ctx: CTX) -> ([T2; N], CTX) { \
    let (arr1, arr2): ([T1; HALF_N], [T1; HALF_N]) = <[T1; N]>::into(arr); \
    let (res1, ctx): ([T2; HALF_N], CTX) = PREFIX##_map_arr_##HALF_N(arr1, ctx); \
    let (res2, ctx): ([T2; HALF_N], CTX) = PREFIX##_map_arr_##HALF_N(arr2, ctx); \
    let res: [T2; N] = <([T2; HALF_N], [T2; HALF_N])>::into((res1, res2)); \
    (res, ctx) \
}

/// Map a list of size <2.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the list.
/// * `T2` is the type of the elements in the list after mapping.
/// * `CTX` is the context of the mapping function.
/// * `F` is the mapping function.
/// Returns a tuple of the mapped list and the updated context.
#define DEFINE_MAP_LST_2(PREFIX, T1, T2, CTX, F) \
fn PREFIX##_map_lst_2(l: List<T1, 2>, ctx: CTX) -> (List<T2, 2>, CTX) { \
    let elt: Option<T1> = <List<T1, 2>>::into(l); \
    match elt { \
        Some(elt1: T1) => { \
            let (elt2, ctx): (T2, CTX) = F(elt1, ctx); \
            (list![elt2], ctx) \
        }, \
        None => (list![], ctx), \
    } \
}

/// Map a list of size <N.
/// * `PREFIX` is the prefix of the function name.
/// * `T1` is the type of the elements in the list.
/// * `T2` is the type of the elements in the list after mapping.
/// * `CTX` is the context of the mapping function.
/// * `F` is the mapping function.
/// * `N` is the max size of the list.
/// * `HALF_N` is the max size of the list after splitting in half.
/// Returns a tuple of the mapped list and the updated context.
#define DEFINE_MAP_LST(PREFIX, T1, T2, CTX, F, N, HALF_N) \
fn PREFIX##_map_lst_##N(l: List<T1, N>, ctx: CTX) -> (List<T2, N>, CTX) { \
    let (l_arr, l_lst): (Option<[T1; HALF_N]>, List<T1, HALF_N>) = <List<T1, N>>::into(l); \
    let (res_arr, ctx): (Option<[T2; HALF_N]>, CTX) = match l_arr { \
        Some(arr1: [T1; HALF_N]) => { \
            let (arr2, ctx): ([T2; HALF_N], CTX) = PREFIX##_map_arr_##HALF_N(arr1, ctx); \
            (Some(arr2), ctx) \
        }, \
        None => (None, ctx), \
    }; \
    let (res_lst, ctx): (List<T2, HALF_N>, CTX) = PREFIX##_map_lst_##HALF_N(l_lst, ctx); \
    let res: List<T2, N> = <(Option<[T2; HALF_N]>, List<T2, HALF_N>)>::into((res_arr, res_lst)); \
    (res, ctx) \
}

/// Identity function for tests.
fn identity(elt: u32, ctx: u32) -> (u32, u32) {
    (elt, ctx)
}

// The order in which we define function matters.
// First we define mappers for arrays, then lists.
// First for lower sizes, then for higher sizes.
DEFINE_MAP_ARR_2(num, u32, u32, u32, identity)
DEFINE_MAP_ARR(num, u32, u32, u32, identity, 4, 2)
DEFINE_MAP_ARR(num, u32, u32, u32, identity, 8, 4)

DEFINE_MAP_LST_2(num, u32, u32, u32, identity)
DEFINE_MAP_LST(num, u32, u32, u32, identity, 4, 2)
DEFINE_MAP_LST(num, u32, u32, u32, identity, 8, 4)

fn test_map_lst_8() {
    let a: List<u32, 8> = list![1, 2, 3, 4, 5];
    let (mapped, ctx): (List<u32, 8>, u32) = num_map_lst_8(a, 0);
}

#endif
