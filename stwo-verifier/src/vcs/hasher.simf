// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef HASHER_SIMF
#define HASHER_SIMF

#include "poly/evaluations.simf"
#include "vcs/merkle.simf"

/// SHA256 hash of a 256-bit value (big-endian).
fn sha256(input: u256) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, input);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// SHA256 hash of a 32-bit value (big-endian).
fn sha256_32(input: u32) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_4(ctx, input);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// SHA256 hash of a concatenation of two 256-bit values (big-endian).
fn sha256_pair(left: u256, right: u256) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, left);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, right);
    jet::sha_256_ctx_8_finalize(ctx)
}

fn hasher_add_m31(eval: M31, ctx: Ctx8) -> Ctx8 {
    jet::sha_256_ctx_8_add_4(ctx, eval)
}

fn hasher_add_m31_column(col_evals: ColEvalsM31, ctx: Ctx8) -> Ctx8 {
    fold::<hasher_add_m31, COL_MAX_OFFSET>(col_evals, ctx)
}

fn hash_node_m31_trace(trace_evals: TraceEvalsM31) -> MerkleNode {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = fold::<hasher_add_m31_column, MAX_COLUMNS>(trace_evals, ctx);
    jet::sha_256_ctx_8_finalize(ctx)
}

fn hash_node_m31_cp(cp_eval: CPEvalM31) -> MerkleNode {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let (cp0, cp1, cp2, cp3): (M31, M31, M31, M31) = <CPEvalM31>::into(cp_eval);
    let ctx: Ctx8 = hasher_add_m31(cp0, ctx);
    let ctx: Ctx8 = hasher_add_m31(cp1, ctx);
    let ctx: Ctx8 = hasher_add_m31(cp2, ctx);
    let ctx: Ctx8 = hasher_add_m31(cp3, ctx);
    jet::sha_256_ctx_8_finalize(ctx)
}

fn test_sha256() {
    let input: u256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let result: u256 = sha256(input);
    assert!(jet::eq_256(result, 0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925));
}

fn test_sha256_32() {
    let input: u32 = 2915689030;
    let result: u256 = sha256_32(input);
    assert!(jet::eq_256(result, 64711419806867828842001989061968035503454892533703351743109315571114974747662));
}

#endif
