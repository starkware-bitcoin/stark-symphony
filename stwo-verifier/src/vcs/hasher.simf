// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef HASHER_SIMF
#define HASHER_SIMF

#include "poly/evaluations.simf"

/// SHA256 hash of a 256-bit value (big-endian).
fn sha256(input: u256) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, input);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// SHA256 hash of a 32-bit value (big-endian).
fn sha256_32(input: u32) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_4(ctx, input);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// SHA256 hash of a concatenation of two 256-bit values (big-endian).
fn sha256_pair(left: u256, right: u256) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, left);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, right);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// Add an M31 value to the SHA256 context.
fn hasher_add_m31(eval: M31, ctx: Ctx8) -> Ctx8 {
    jet::sha_256_ctx_8_add_4(ctx, dbg!(eval))
}

/// Add a column of M31 values to the SHA256 context.
fn hasher_add_m31_column(col_evals: ColEvalsM31, ctx: Ctx8) -> Ctx8 {
    fold::<hasher_add_m31, COL_MAX_OFFSET>(col_evals, ctx)
}

/// Hash multiple M31 columns (trace evaluations).
fn hash_node_m31_trace(trace_evals: TraceEvalsM31) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = fold::<hasher_add_m31_column, MAX_COLUMNS>(trace_evals, ctx);
    jet::sha_256_ctx_8_finalize(ctx)
}

/// Hash a partitioned composition polynomial evaluation.
fn hash_node_m31_cp(cp_eval: CPEvalM31) -> u256 {
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    // Convert array to list to be able to fold
    let cp_eval_list: List<M31, 32> = <(Option<CPEvalM31>, List<M31, 16>)>::into((Some(cp_eval), list![]));
    let ctx: Ctx8 = fold::<hasher_add_m31, 32>(cp_eval_list, ctx);
    jet::sha_256_ctx_8_finalize(ctx)
}

fn test_sha256() {
    let input: u256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let result: u256 = sha256(input);
    assert!(jet::eq_256(result, 0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925));
}

fn test_sha256_32() {
    let input: u32 = 2915689030;
    let result: u256 = sha256_32(input);
    assert!(jet::eq_256(result, 64711419806867828842001989061968035503454892533703351743109315571114974747662));
}

#endif
