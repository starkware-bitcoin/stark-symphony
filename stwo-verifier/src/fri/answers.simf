// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef FRI_ANSWERS_SIMF
#define FRI_ANSWERS_SIMF

#include "config.simf"
#include "deep/oods.simf"
#include "deep/quotients.simf"
#include "evals/decommit.simf"
#include "groups/circle_domain.simf"
#include "macros/array_zip.simf"
#include "macros/array_map.simf"
#include "macros/array_fold.simf"

/// FRI answer is a pair of a query and a random linear combination of quotients.
type FriAnswer = (u32, QM31);

/// Zip trace column evaluations with OODS trace column evaluations.
/// CONFIG: define the macro for the current NUM_COLUMNS.
DEFINE_ZIP_ARR_1(trace_evals, ColEvalsM31, ColEvalsQM31)
DEFINE_ZIP_ARR(trace_evals, ColEvalsM31, ColEvalsQM31, 2, 1)
DEFINE_ZIP_ARR(trace_evals, ColEvalsM31, ColEvalsQM31, 4, 2)

/// Zip composition polynomial evaluations with OODS composition polynomial evaluations.
/// CONFIG: define the macro for the current NUM_CP_PARTITIONS.
DEFINE_ZIP_ARR_1(cp_evals, M31, QM31)
DEFINE_ZIP_ARR(cp_evals, M31, QM31, 2, 1)
DEFINE_ZIP_ARR(cp_evals, M31, QM31, 4, 2)
DEFINE_ZIP_ARR(cp_evals, M31, QM31, 8, 4)
DEFINE_ZIP_ARR(cp_evals, M31, QM31, 16, 8)

/// Accumulator for the quotient numerator (for a single batch):
/// * quotient numerator accumulator value
/// * column offset
/// * domain point (for the given query position and column element offset)
/// * OODS point
/// * random coefficient
/// * alpha^i where initial alpha value is 1 and each time it is multiplied by the random coefficient
type NumeratorAcc = (QM31, u32, M31Point, QM31Point, QM31, QM31);

/// Aggregate quotient numerators for a single evaluation.
fn quotient_numerator_aggregate(evals: (M31, QM31), acc: NumeratorAcc) -> NumeratorAcc {
    let (numerator_acc, column_offset, domain_point, oods_point, random_coeff, alpha_i): NumeratorAcc = acc;
    let (value, oods_value): (M31, QM31) = evals;

    // Compute coefficients.
    let interpolant_coefficients: (QM31, QM31, QM31) = deep_quotient_interpolant_coefficients(oods_point, oods_value, alpha_i);

    // Compute quotient numerator.
    let numerator: QM31 = deep_quotient_nominator(interpolant_coefficients, domain_point, value);

    // Add quotient numerator to the accumulator.
    let numerator_acc: QM31 = qm31_add(numerator_acc, numerator);

    // Update alpha_i.
    let alpha_i: QM31 = qm31_mul(alpha_i, random_coeff);

    // Return the updated accumulator.
    (numerator_acc, column_offset, domain_point, oods_point, random_coeff, alpha_i)
}

/// Aggregate quotient numerators for a single trace column depending on the point offset.
fn trace_quotient_numerator_aggregate(evals: (ColEvalsM31, ColEvalsQM31), acc: NumeratorAcc) -> NumeratorAcc {
    let (col_evals, oods_col_evals): (ColEvalsM31, ColEvalsQM31) = evals;
    let (_, offset, _, _, _, _): NumeratorAcc = acc;

    // Get the column evaluation and the OODS column evaluation by index.
    let col_eval: M31 = col_evals_m31_get(col_evals, offset);
    let oods_col_eval: QM31 = col_evals_qm31_get(oods_col_evals, offset);

    // Aggregate the quotient numerators.
    quotient_numerator_aggregate((col_eval, oods_col_eval), acc)
}

/// Context for mapping query responses to FRI answers.
/// * random coefficient
/// * OODS point
/// * OODS evaluations
/// * log size
type QueryResponseCtx = (QM31, QM31Point, OodsEvals, u8);

// CONFIG: define the macro for the current NUM_COLUMNS.
DEFINE_FOLD_ARR_1(trace_quotient_numerator, (ColEvalsM31, ColEvalsQM31), NumeratorAcc, trace_quotient_numerator_aggregate)
DEFINE_FOLD_ARR(trace_quotient_numerator, (ColEvalsM31, ColEvalsQM31), NumeratorAcc, trace_quotient_numerator_aggregate, 2, 1)
DEFINE_FOLD_ARR(trace_quotient_numerator, (ColEvalsM31, ColEvalsQM31), NumeratorAcc, trace_quotient_numerator_aggregate, 4, 2)

// CONFIG: define the macro for the current NUM_CP_PARTITIONS.
DEFINE_FOLD_ARR_1(quotient_numerator, (M31, QM31), NumeratorAcc, quotient_numerator_aggregate)
DEFINE_FOLD_ARR(quotient_numerator, (M31, QM31), NumeratorAcc, quotient_numerator_aggregate, 2, 1)
DEFINE_FOLD_ARR(quotient_numerator, (M31, QM31), NumeratorAcc, quotient_numerator_aggregate, 4, 2)
DEFINE_FOLD_ARR(quotient_numerator, (M31, QM31), NumeratorAcc, quotient_numerator_aggregate, 8, 4)
DEFINE_FOLD_ARR(quotient_numerator, (M31, QM31), NumeratorAcc, quotient_numerator_aggregate, 16, 8)

/// Mapper function for mapping a query response to a FRI answer.
fn fri_answer(response: QueryResponse, ctx: QueryResponseCtx) -> (FriAnswer, QueryResponseCtx) {
    let (random_coeff, oods_point, oods_evals, log_size): QueryResponseCtx = ctx;
    let (query, trace_evals, cp_evals): QueryResponse = response;
    let (oods_trace_evals, oods_cp_evals): OodsEvals = oods_evals;

    // Zip queried evaluations with sampled evaluations.
    let zipped_trace_evals: [(ColEvalsM31, ColEvalsQM31); NUM_COLUMNS] = trace_evals_zip_arr_4(trace_evals, oods_trace_evals);
    let zipped_cp_evals: [(M31, QM31); NUM_CP_PARTITIONS] = cp_evals_zip_arr_16(cp_evals, oods_cp_evals);

    // Compute the domain point from the query position and column offset 0.
    let domain: CanonicCoset = circle_canonic_coset(log_size);
    let position: u32 = bit_reverse_index(query, log_size);
    let domain_point: M31Point = circle_position_to_m31_point(domain, position);

    // Compute quotient denominator inverse.
    let denominator_inv: CM31 = deep_quotient_denominator_inverse(oods_point, domain_point);

    // Aggregate the quotient numerators.
    // Quotient numerator accumulator = 0, column offset = 0, alpha_1 = random_coeff
    let acc: NumeratorAcc = (qm31(0, 0, 0, 0), 0, domain_point, oods_point, random_coeff, random_coeff);
    // CONFIG: use the macro for the current NUM_COLUMNS.
    let acc: NumeratorAcc = trace_quotient_numerator_fold_arr_4(zipped_trace_evals, acc);

    // TODO: process for other offsets (not needed for the current AIR)

    let (acc, _, _, _, _, batch_coeff): NumeratorAcc = quotient_numerator_fold_arr_16(zipped_cp_evals, acc);

    // Batch coefficient is random coefficient to the power of the number of columns in the batch.
    // This is basically alpha^i after the last column is processed.
    let quotient: QM31 = qm31_mul(qm31_mul_cm31(acc, denominator_inv), batch_coeff);

    // Return the FRI answer and the context.
    ((query, quotient), ctx)
}

/// Map query responses to FRI answers.
/// CONFIG: define the macro for the current NUM_FRI_QUERIES.
DEFINE_MAP_ARR_1(QueryResponse, FriAnswer, QueryResponseCtx, fri_answer)
DEFINE_MAP_ARR(QueryResponse, FriAnswer, QueryResponseCtx, fri_answer, 2, 1)
DEFINE_MAP_ARR(QueryResponse, FriAnswer, QueryResponseCtx, fri_answer, 4, 2)
DEFINE_MAP_ARR(QueryResponse, FriAnswer, QueryResponseCtx, fri_answer, 8, 4)
DEFINE_MAP_ARR(QueryResponse, FriAnswer, QueryResponseCtx, fri_answer, 16, 8)

/// Map query responses to FRI answers.
fn fri_answer_map_arr(responses: [QueryResponse; NUM_FRI_QUERIES], ctx: QueryResponseCtx) -> ([FriAnswer; NUM_FRI_QUERIES], QueryResponseCtx) {
#ifdef TESTING
    fri_answer_map_arr_1(responses, ctx)
#else
    fri_answer_map_arr_16(responses, ctx)
#endif // TESTING
}

/// Map query responses to FRI answers.
fn fri_answers(responses: [QueryResponse; NUM_FRI_QUERIES], random_coeff: QM31, oods_point: QM31Point, oods_evals: OodsEvals, log_size: u8) -> [FriAnswer; NUM_FRI_QUERIES] {
    let ctx: QueryResponseCtx = (random_coeff, oods_point, oods_evals, log_size);
    let (fri_answers, _): ([FriAnswer; NUM_FRI_QUERIES], QueryResponseCtx) = fri_answer_map_arr(responses, ctx);
    fri_answers
}

fn test_trace_evals_zip_arr_4() {
    let evals: [ColEvalsM31; 4] = [
        [1],
        [2],
        [3],
        [4],
    ];
    let oods_evals: [ColEvalsQM31; 4] = [
        [qm31(1, 0, 0, 0)],
        [qm31(2, 0, 0, 0)],
        [qm31(3, 0, 0, 0)],
        [qm31(4, 0, 0, 0)],
    ];
    let zipped: [(ColEvalsM31, ColEvalsQM31); 4] = trace_evals_zip_arr_4(evals, oods_evals);
}

fn test_cp_evals_zip_arr_4() {
    let evals: [M31; 4] = [1, 2, 3, 4];
    let oods_evals: [QM31; 4] = [qm31(1, 0, 0, 0), qm31(2, 0, 0, 0), qm31(3, 0, 0, 0), qm31(4, 0, 0, 0)];
    let zipped: [(M31, QM31); 4] = cp_evals_zip_arr_4(evals, oods_evals);
}

#endif
