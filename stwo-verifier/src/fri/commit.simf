// SPDX-FileCopyrightText: 2025 StarkWare Industries Ltd.
//
// SPDX-License-Identifier: MIT

#ifndef FRI_COMMIT_SIMF
#define FRI_COMMIT_SIMF

#include "config.simf"
#include "channel.simf"
#include "hasher.simf"
#include "fields/qm31.simf"
#include "merkle.simf"
#include "macros/array_map.simf"

/// FRI commitments:
/// * first and inner layers commitments
/// * last layer: line polynomial coefficient (always degree 0)
type FriCommitments = ([u256; NUM_FRI_LAYERS], QM31);

/// FRI layer:
/// * commitment
/// * folding alpha
type FriLayer = (u256, QM31);

/// FRI layers:
/// * first layer
/// * inner layers
/// * last layer: line polynomial coefficient (always degree 0)
type FriLayers = ([FriLayer; NUM_FRI_LAYERS], QM31);

/// Reads the FRI layer commitment and samples a random coefficient.
/// Fails if the computed FRI layer evaluation does not match the pre-sampled FRI layer evaluation.
fn fri_layer_commit(root: u256, state: ChannelState) -> (FriLayer, ChannelState) {
    // Mix the commitment into the state.
    let state: ChannelState = channel_mix_u256(state, root);

    // Draw folding alpha from the state
    let (state, random_coeff): (ChannelState, QM31) = channel_draw_qm31(state);

    // Return the FRI layer and the updated state
    ((root, random_coeff), state)
}

/// Mix line polynomial coefficients into the channel state.
fn channel_mix_line_poly(state: ChannelState, line_poly_coeff: QM31) -> ChannelState {
    let (digest, _): ChannelState = state;
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, digest);
    // Mix coefficients
    let ctx: Ctx8 = hasher_add_qm31(line_poly_coeff, ctx);
    let res: u256 = jet::sha_256_ctx_8_finalize(ctx);
    // Reset the num_sent counter
    (res, 0)
}

// CONFIG: see NUM_FRI_LAYERS.
DEFINE_MAP_ARR_1(u256, FriLayer, ChannelState, fri_layer_commit)
DEFINE_MAP_ARR(u256, FriLayer, ChannelState, fri_layer_commit, 2, 1)
DEFINE_MAP_ARR(u256, FriLayer, ChannelState, fri_layer_commit, 4, 2)
DEFINE_MAP_ARR(u256, FriLayer, ChannelState, fri_layer_commit, 8, 4)

fn fri_layer_commit_map_arr(commitments: [u256; NUM_FRI_LAYERS], state: ChannelState) -> ([FriLayer; NUM_FRI_LAYERS], ChannelState) {
#ifdef TESTING
    fri_layer_commit_map_arr_2(commitments, state)
#else
    fri_layer_commit_map_arr_8(commitments, state)
#endif // TESTING
}

/// Commits the FRI layers.
fn fri_commit(state: ChannelState, fri_commitments: FriCommitments) -> (ChannelState, FriLayers) {
    let (commitments, line_poly_coeff): FriCommitments = fri_commitments;

    // Commit first and inner layers
    let (layers, state): ([FriLayer; NUM_FRI_LAYERS], ChannelState) = fri_layer_commit_map_arr(commitments, state);

    // Commit last layer (line polynomial coefficients)
    let state: ChannelState = channel_mix_line_poly(state, line_poly_coeff);

    (state, (layers, line_poly_coeff))
}

#ifdef TESTING

fn test_fri_commit() {
    let state: ChannelState = (0x28583eb83f6fe4837a995243e8e5c2648edbfd9cdd06262edcbce47fe96e5e3c, 0);
    let fri_commitments: FriCommitments = (
        [0x0bee0d98d63597a3b6725c885e77c23647585e29ae3ebd3b3b88bdba21f30f13, 0xd63312459c0bd0456789cce101ab292880c3bf103514eb22bd7457808388423e],
        qm31(502777192, 1639915013, 504572960, 826242631),
    );
    let ((digest, _), layers): (ChannelState, FriLayers) = fri_commit(state, fri_commitments);
    assert!(jet::eq_256(digest, 0x3532bad0c22ceae1a8c9e137dfde35b18e8bd4a08ce6c5e64ea3d9465a517f82));

    let (layers, _): FriLayers = layers;
    let ((_, first_alpha), _): (FriLayer, FriLayer) = <[FriLayer; NUM_FRI_LAYERS]>::into(layers);
    assert!(qm31_eq(first_alpha, qm31(766788992, 1201991280, 1148418600, 2122329945)));
}

#endif // TESTING

#endif
